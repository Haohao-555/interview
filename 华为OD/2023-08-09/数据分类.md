# 统计监控，需要打开多少监控器

## 一、题目描述

对一个数据 a 进行分类分类方法是：此数据 a（4 个字节大小）的 4 个字节相加对一个给定值 b ，并对其取模。如果得到的结果小于一个给定的值 c 则数据 a 为有效类型，反之，如果得到的结果大于或者等于 c 则数据 a 为无效类型

比如一个数据 a = 0x01010101， b = 3
按照分类方法计算: (0x01 + 0x01 + 0x01 + 0x01) % 3 = 1
所以如果 c 等于 2，则此 a 就是有效类型，其类型为 1； 如果 c等于1，则此 a 是无效类型

如一个数据 a = 0x01010103， b = 3
按分类方法计算: (0x01 + 0x01 + 0x01 + 0x03) % 3 = 0
所以如果 c = 2 则此 a 就是有效类型，其类型为 o；如果 c = o 则此 a 是无效类型

## 二、输入

输入 12 个数据，第一个数据为 c，第二个数据为 b，剩余 10 个数据为需要分类的数据。

## 三、输出

请找到有效类型中包含数据最多的类型并输出该类型含有多少个数据

## 四、示例

```
// 输入：3 4 256 257 258 259 260 261 262 263 264 265

// 则 c 为 3；b 为 4

// 这 10 个数据 4 个字节相加后的结果分别是1 2 3 4 5 6 7 8 9 10
// 故对 b 取模 的结果为 1 2 3 0 1 2 3 0 1 2 
// c 是 3 
// 所以 0 1 2 都是有效类型类型
// 而 1 和 2 的有 3 个数据；0 的有 3 个数据

// 输出为 3
```

## 五、题目理解

对每一个数字转成 十六进制，并将其平等拆分成四分，每份为四字节：（ox01010101 => (0x01， 0x01，0x01，0x01)）。并将其相加得出的结果，对其进行取模（b）。其后判断其是否符合小于 c，若满足则符合类型。并最终记录每种类型的个数，找到最终类型个数最多的个数。

## 六、解题关键

第一点：如何把十六进制数，拆分成四分，每份为四字节。这里涉及到的知识点：位运算

下面例子已 256 为例子进行拆分。采用反推的方式

```
// 预取结果：
// 257 => 0x100 => 0x00000101
// 拆分后：0x01 0x01 0x00 0x00

// 补齐 8 位
0x01 => 0x00000001   
0x01 => 0x00000001   
0x00 => 0x00000000
0x00 => 0x00000000

// 输入 256 => 0x00000100

// 第一个值： 0x00000101 右移 0 位 0x00000001 前六位都置为 0 
// 得到  0x00000001

// 第二个值： 0x00000101 右移 2 位 0x0000000101 前六位都置为 0 （从高位到低位，最后2位去掉01）
// 得到 0x00000001

// 第三个值： 0x00000101 右移 4 位 0x000000000101 前六位都置为 0 （从高位到低位，最后4位去掉0101） 
// 得到 0x00000000

// 第四个值： 0x00000101 右移 6 位 0x00000000000101 前六位都置为 0 （从高位到低位，最后6位去掉000101）
// 得到 0x00000000
```



## 七、解题

```javascript
const test = () => {
    
    const intByteSum = (x) => {
        let sum = 0;
        // 对 x 每个字节进行累加
        for (let i = 0; i < 4; ++i) {
            sum += (x >> (i * 8)) & 0xff;
        }
        return sum;
    }

    const arr = str.split(" ");
    const c = arr[0];
    const b = arr[1];
    const map = new Map();
    for(let i = 2; i < arr.length; i++) {
        const number = arr[i];
        const r = intByteSum(number) % b

        // 符合要求进入到 map 中并进行计数
        if (r < c) {
            map.set(r, (map.get(r) || 0) + 1);
        }
    }

    // 计算出现数据类型最多的次数
    let max = 0;
    for (const value of map.values()) {
        if (value > max) {
            max = value
        }
    }
    return max;
}
console.log(test("3 4 256 257 258 259 260 261 262 263 264 265")) 
```